%prelude {
#include "yystype.h"
#include "outputHandler.h"

int arrDecNumber = 0;
int arrDecProduction = 1;

int arrCmptProduction = 1;

Array parametersArray;

char* variableType;

int useOfArrayVar = 0;

int = useOfResVar = 0;
char* VariableName;

}
	 
%token CHAR, STRING, TRUEV, FALSEV, ID_CODE, INTNUMBER, REALNUMBER, NOTEQUAL, NOT, LESSOREQUAL, LESSTHAN, BIGGEROREQUAL, BIGGERTHAN, EQUAL, ASSIGNMENT, DECREMENT, SUBUNARYMINUS, INCREMENT, ADDUNARYPLUS, DIV, PRODUCTION, MOD, LOGICALAND, ARITHMETICAND, LOGICALOR, ARITHMETICOR, XOR, OPENCURLYBRACE, CLOSECURLYBRACE, OPENINGBRACE, CLOSINGBRACE, OPENINGPAREBTHESIS, CLOSINGPAREBTHESIS, COMMA, SEMICOLON, COLON, EOF, BOOLEAN, BREAK, CASE, CHARKEYWORD, CONST, CONTINUE, DEFAULT, DOUBLE, ELSE, EXTERN, FUNCTION, FLOAT, FOR, GOTO, IF, INPUT, INT, LONG, OUTPUT, RETURN, SIZEOF, STATIC, STRINGKEYWORD, SWITCH, VOID, AUTO, RECORD, REPEAT, PROCEDURE, FOREACH, OF, IN, UNTIL;

%nodefault

null_point :

;

program :
  program_parts
| program_parts program
;

program_parts:
  var_dcl
| func_proc
| struct_dec
;

func_proc :
  func_dcl<x> { HandleCodeGenerator("END", x, "", ""); }
| proc_dcl
| extern_dcl
;

arguments :
| argument
| argument COMMA arguments
;

array_dcl<n> :
	%prelude { int simpleArray = 1; }
  null_point { if (arrDecNumber == 0) { *n = 0; } else { if (simpleArray == 1) { *n = 1; } else {*n = arrDecProduction; arrDecProduction = 1; } } arrDecNumber = 0; }
| OPENINGBRACE CLOSINGBRACE { arrDecNumber++; simpleArray = 1; } array_dcl
| OPENINGBRACE INTNUMBER<x> CLOSINGBRACE { arrDecNumber++;  simpleArray = 0; arrDecProduction*= x; } array_dcl
;

argument :
  type<x> ID_CODE<y> array_dcl<z> { char* size; if (z == 0) { size = GetSizeOf(x); HandleCodeGenerator("ARG", size, y, ""); } else { size = GetSizeOf(x); char* arrSzie = itoa(z); HandleCodeGenerator("ARG", size, arrSize, y); } }
;

func_dcl<n> :
  type<x> ID_CODE<y> { char* size = GetSizeOf(x); HandleCodeGenerator("FUN", y, size, ""); } OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS SEMICOLON { *n = y }
| type<x> ID_CODE<y> { char* size = GetSizeOf(x); HandleCodeGenerator("FUN", y, size, ""); } OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS block { *n = y }
;

extern_dcl :
  EXTERN type ID_CODE SEMICOLON
;

proc_dcl :
  PROCEDURE ID_CODE OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS SEMICOLON
| PROCEDURE ID_CODE OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS block
;

type<n> :
  INT {*n = "int"}
| BOOLEAN {*n = "bool"}
| FLOAT {*n = "float"}
| LONG {*n = "long"}
| CHARKEYWORD {*n = "char"}
| DOUBLE {*n = "double"}
| ID_CODE<m> {*n = m} 
| STRINGKEYWORD {*n = "string"}
| VOID {*n = "void"}
| AUTO {*n = "auto"}
;

var_dcl:
  %prelude { int i = 0; }
  ( CONST { i = 1; } )? type<x> { variableType = x; } var_dcl_cnts SEMICOLON { }
;

var_dcl_cnts:
  var_dcl_cnt
| var_dcl_cnt COMMA var_dcl_cnts
;
    
var_dcl_cnt:
  variable<x> { size = GetSizeOf(variableType); if (useOfArrayVar == 0) { HandleCodeGenerator("VAR", size, x, ""); } else { HandleCodeGenerator("ARR", size, arrCmptProduction, x); arrCmptProduction = 1; useOfArrayVar = 0; } }
| assignment_expr 
;

struct_dec:
  RECORD ID_CODE OPENCURLYBRACE var_dcl CLOSECURLYBRACE SEMICOLON
;

block<n> :
  OPENCURLYBRACE ( ( var_dcl | statement_expr ) )* CLOSECURLYBRACE { *n = ProduceBlockLabel(); }
;

arithmatic_low_level<n> :
  ADDUNARYPLUS<x> {*n = x}
| SUBUNARYMINUS<x> {*n = x}
;

arithmatic_high_level<n> :
  PRODUCTION<x> {*n = x}
| DIV<x> {*n = x}
| MOD<x> {*n = x}
| ARITHMETICAND<x> {*n = x}
| ARITHMETICOR<x> {*n = x}
| XOR<x> {*n = x}
| LOGICALOR<x> {*n = x}
| LOGICALAND<x> {*n = x}
;

arithmatic<n> :
  ADDUNARYPLUS<x> {*n = x}
| SUBUNARYMINUS<x> {*n = x}
| PRODUCTION<x> {*n = x}
| DIV<x> {*n = x}
| MOD<x> {*n = x}
| ARITHMETICAND<x> {*n = x}
| ARITHMETICOR<x> {*n = x}
| XOR<x> {*n = x}
| LOGICALOR<x> {*n = x}
| LOGICALAND<x> {*n = x}
;

conditional<n> :
  EQUAL<x> {*n = x}
| NOTEQUAL<x> {*n = x}
| BIGGEROREQUAL<x> {*n = x}
| LESSOREQUAL<x> {*n = x}
| LESSTHAN<x> {*n = x}
| BIGGERTHAN<x> {*n = x}
;

binary_op<n> :
  arithmatic<x> {*n = x}
| conditional<x> {*n = x}
;

parameters<n> :
  expr<x> { insertArray(&parametersArray, x); *n = ProduceParameters(&parametersArray); freeArray(&parametersArray); }
| expr<x> { insertArray(&parametersArray, x); } COMMA parameters
;

method_call_expr :
	%prelude { int hasParameters = 0; }
  ID_CODE<x> OPENINGPAREBTHESIS ( { initArray(&parametersArray, 5); } parameters<y> { hasParameters = 1; } )? CLOSINGPAREBTHESIS { if(hasParameters == 0) { HandleCodeGenerator("CALL",x,"",""); } else { HandleCodeGenerator("CALL",x,y,""); } }
;

array_complete_dcl<n> :
  OPENINGBRACE expr<x> CLOSINGBRACE { *n = arrCmptProduction * x; }
| OPENINGBRACE expr<x> CLOSINGBRACE { arrCmptProduction = arrCmptProduction * x; } array_complete_dcl<y> 
;

variable<n> :
  ID_CODE<x> { *n = x; }
| ID_CODE<x> array_complete_dcl<y> { useOfArrayVar = 1; *n = x; }
| DECREMENT variable
| INCREMENT variable
| variable DECREMENT
| variable INCREMENT
;

const_val<n> :
  INTNUMBER<x> { *n = x; }
| REALNUMBER<x> { *n = x; }
| CHAR<x> { *n = x; }
| BOOLEAN<x> { *n = x; }
| STRING<x> { *n = x; }
;

assignment_expr<n> :
  variable<x> { useOfResVar = 1; VariableName = x; } ASSIGNMENT expr<y> { HandleCodeGenerator("=",x,y,""); useOfResVar = 0; }
;

expr_assign:
  expr 
| assignment_expr
;

loop_stmt :
  FOR OPENINGPAREBTHESIS ( var_dcl )? SEMICOLON expr SEMICOLON ( expr_assign )? CLOSINGPAREBTHESIS block
| REPEAT block UNTIL OPENINGPAREBTHESIS expr CLOSINGPAREBTHESIS SEMICOLON
| FOREACH OPENINGPAREBTHESIS ID_CODE IN ID_CODE CLOSINGPAREBTHESIS block
;

term<n> :
  term<x> arithmatic_low_level<y> factor<y> { char* temp = ProduceTempVar(); HandleCodeGenerator(y,temp,x,z); *n = temp; }
| factor<x>
;

factor<n> :
  factor<x> arithmatic_high_level<y> primary<z> { char* temp = ProduceTempVar(); HandleCodeGenerator(y,temp,x,z); *n = temp; }
| primary<x> { *n = x; }
;

primary<n> :
  INTNUMBER<x> { *n = x; }
| REALNUMBER<x> { *n = x; }
| OPENINGPAREBTHESIS term<x> CLOSINGPAREBTHESIS
;

expr<n> :
  term<x>
| expr conditional expr
| OPENINGPAREBTHESIS expr CLOSINGPAREBTHESIS
| method_call_expr
| variable<x> { *n = x; }
| const_val
| SUBUNARYMINUS expr
| NOT expr
;

cond_statement :
  IF OPENINGPAREBTHESIS expr<x> CLOSINGPAREBTHESIS block<y> { char* blockLabel = UseOfBlockLabel(); HandleCodeGenerator("JNZ",blockLabel,x,""); } ( ELSE block<z> { char* blockLabel = UseOfBlockLabel(); HandleCodeGenerator("JZ",blockLabel,z,""); } )?
| SWITCH OPENCURLYBRACE ID_CODE<x> CLOSINGPAREBTHESIS OF COLON OPENCURLYBRACE ( CASE INTNUMBER<y> COLON block<z> )* DEFAULT COLON block CLOSECURLYBRACE
;

gotofunc :
  GOTO ID_CODE<x> { HandleCodeGenerator("JMP",x,"",""); }
;

labeltoken :
  ID_CODE<x> COLON { HandleCodeGenerator("LB",x,"",""); }
;

statement_expr :
  assignment_expr SEMICOLON
| cond_statement
| loop_stmt
| method_call_expr SEMICOLON
| RETURN { int i = 0; }( expr<x> { i = 1; })? SEMICOLON { if(i == 0) { HandleCodeGenerator("RET",x,"",""); } else HandleCodeGenerator("RET","","",""); };
| gotofunc SEMICOLON
| labeltoken
| BREAK SEMICOLON
| CONTINUE SEMICOLON
| SIZEOF OPENINGPAREBTHESIS type CLOSINGPAREBTHESIS SEMICOLON
;