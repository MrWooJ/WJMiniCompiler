%prelude {
#include "SymbolTableHandler.h"
#include "OutputHandler.h"
#include "Utility.h"

int arrDecNumber = 0;
int arrDecProduction = 1;

int arrCmptProduction = 1;

Array parametersArray;

char* variableType;

int useOfArrayVar = 0;

int useOfResVar = 0;

char* VariableName;

}

%token CHAR, STRING, TRUEV, FALSEV, ID_CODE, INTNUMBER, REALNUMBER, NOTEQUAL, NOT, LESSOREQUAL, LESSTHAN, BIGGEROREQUAL, BIGGERTHAN, EQUAL, ASSIGNMENT, DECREMENT, SUBUNARYMINUS, INCREMENT, ADDUNARYPLUS, DIV, PRODUCTION, MOD, LOGICALAND, ARITHMETICAND, LOGICALOR, ARITHMETICOR, XOR, OPENCURLYBRACE, CLOSECURLYBRACE, OPENINGBRACE, CLOSINGBRACE, OPENINGPAREBTHESIS, CLOSINGPAREBTHESIS, COMMA, SEMICOLON, COLON, EOF, BOOLEAN, BREAK, CASE, CHARKEYWORD, CONST, CONTINUE, DEFAULT, DOUBLE, ELSE, EXTERN, FUNCTION, FLOAT, FOR, GOTO, IF, INPUT, INT, LONG, OUTPUT, RETURN, SIZEOF, STATIC, STRINGKEYWORD, SWITCH, VOID, AUTO, RECORD, REPEAT, PROCEDURE, FOREACH, OF, IN, UNTIL;

%nodefault

null_point :
;

program :
	%prelude { PrepareST(); }
  program_parts
| program_parts program
;

program_parts :
  var_dcl
| func_proc
| struct_dec
;

func_proc :
  func_dcl<x> { HandleCodeGenerator("END", x, "", ""); }
| proc_dcl
| extern_dcl
;

arguments :
  argument
| argument COMMA arguments
;

array_dcl<n> :
	%prelude { int simpleArray = 1; }
  null_point { if (arrDecNumber == 0) { *n = 0; } else { if (simpleArray == 1) { *n = 1; } else { *n = arrDecProduction; arrDecProduction = 1; } } arrDecNumber = 0; }
| OPENINGBRACE CLOSINGBRACE { arrDecNumber++; simpleArray = 1; } array_dcl<m>
| OPENINGBRACE INTNUMBER<x> CLOSINGBRACE { arrDecNumber++; simpleArray = 0; arrDecProduction = arrDecProduction * x; } array_dcl<m>
;

argument :
	%prelude { int check = 0; char *arrSize1; }
  type<x> ID_CODE<y> { char* str6 = Lookup(y); if ((str6 != NULL) && (str6[0] != '\0')) { AddId(y,x); } else { ErrorPrump_IdDuplicated(1,y); return; } } array_dcl<z> { char* sizex; if (z == 0) { sizex = GetSizeOf(x); HandleCodeGenerator("ARG", sizex, y, ""); } else { sizex = GetSizeOf(x); arrSize1 = Int2String(z); HandleCodeGenerator("ARG", sizex, arrSize1, y); } }
;

func_dcl<n> :
  type<x> ID_CODE<y> { char* str = Lookup(y); if ((str != NULL) && (str[0] != '\0')) { AddId(y,x); } else { ErrorPrump_IdDuplicated(1,y); return; } char* size = GetSizeOf(x); HandleCodeGenerator("FUN", y, size, ""); } OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS SEMICOLON { *n = y; }
| type<x> ID_CODE<y> { char* str = Lookup(y); if ((str != NULL) && (str[0] != '\0')) { AddId(y,x); } else { ErrorPrump_IdDuplicated(1,y); return; } char* size = GetSizeOf(x); HandleCodeGenerator("FUN", y, size, ""); } OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS block<m> { *n = y; }
;

extern_dcl :
  EXTERN type<x> ID_CODE<y> { char* str = Lookup(y); if ((str != NULL) && (str[0] != '\0')) { AddId(y,x); } else { ErrorPrump_IdDuplicated(1,y); return; } } SEMICOLON
;

proc_dcl :
  PROCEDURE ID_CODE OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS SEMICOLON
| PROCEDURE ID_CODE OPENINGPAREBTHESIS ( arguments )? CLOSINGPAREBTHESIS block<m>
;

type<n> :
  INT { *n = "int"; }
| BOOLEAN { *n = "bool"; }
| FLOAT { *n = "float"; }
| LONG { *n = "long"; }
| CHARKEYWORD { *n = "char"; }
| DOUBLE { *n = "double"; }
| ID_CODE<m> { *n = m; } 
| STRINGKEYWORD { *n = "char *"; }
| VOID { *n = "void"; }
| AUTO { *n = "auto"; }
;

var_dcl:
  %prelude { int i = 0; }
  ( CONST { i = 1; } )? type<x> { variableType = x; } var_dcl_cnts SEMICOLON
;

var_dcl_cnts:
  var_dcl_cnt
| var_dcl_cnt COMMA var_dcl_cnts
;
    
var_dcl_cnt:
  variable<x> { char* str4 = Lookup(x); if ((str4 != NULL) && (str4[0] != '\0')) { AddId(x,variableType); } else { ErrorPrump_IdDuplicated(1,x); return; } char* size = GetSizeOf(variableType); if (useOfArrayVar == 0) { HandleCodeGenerator("VAR", size, x, ""); } else { HandleCodeGenerator("ARR", size, arrCmptProduction, x); arrCmptProduction = 1; useOfArrayVar = 0; } }
| assignment_expr<m>
;

struct_dec:
  RECORD ID_CODE<x> { char* str = Lookup(x); if ((str != NULL) && (str[0] != '\0')) { AddId(x,"REC"); } else { ErrorPrump_IdDuplicated(1,x); return; } } OPENCURLYBRACE var_dcl CLOSECURLYBRACE SEMICOLON
;

block<n> :
  OPENCURLYBRACE { EnterScope(); } ( ( var_dcl | statement_expr ) )* CLOSECURLYBRACE { ExitScope(); } { *n = ProduceBlockLabel(); }
;

arithmatic_low_level<n> :
  ADDUNARYPLUS<x> { *n = x; }
| SUBUNARYMINUS<x> { *n = x; }
;

arithmatic_high_level<n> :
  PRODUCTION<x> { *n = x; }
| DIV<x> { *n = x; }
| MOD<x> { *n = x; }
| ARITHMETICAND<x> { *n = x; }
| ARITHMETICOR<x> { *n = x; }
| XOR<x> { *n = x; }
| LOGICALOR<x> { *n = x; }
| LOGICALAND<x> { *n = x; }
;

arithmatic<n> :
  ADDUNARYPLUS<x> { *n = x; }
| SUBUNARYMINUS<x> { *n = x; }
| PRODUCTION<x> { *n = x; }
| DIV<x> { *n = x; }
| MOD<x> { *n = x; }
| ARITHMETICAND<x> { *n = x; }
| ARITHMETICOR<x> { *n = x; }
| XOR<x> { *n = x; }
| LOGICALOR<x> { *n = x; }
| LOGICALAND<x> { *n = x; }
;

conditional<n> :
  EQUAL<x> { *n = x; }
| NOTEQUAL<x> { *n = x; }
| BIGGEROREQUAL<x> { *n = x; }
| LESSOREQUAL<x> { *n = x; }
| LESSTHAN<x> { *n = x; }
| BIGGERTHAN<x> { *n = x; }
;

binary_op<n> :
  arithmatic<x> { *n = x; }
| conditional<x> { *n = x; }
;

parameters<n> :
  expr<x> { insertArray(&parametersArray, x); *n = ProduceParameters(&parametersArray); freeArray(&parametersArray); }
| expr<x> { insertArray(&parametersArray, x); } COMMA parameters<m>
;

method_call_expr :
	%prelude { int hasParameters = 0; }
  ID_CODE<x> OPENINGPAREBTHESIS ( { initArray(&parametersArray, 5); } parameters<y> { hasParameters = 1; } )? CLOSINGPAREBTHESIS { if(hasParameters == 0) { HandleCodeGenerator("CALL",x,"",""); } else { HandleCodeGenerator("CALL",x,y,""); } }
;

array_complete_dcl<n> :
  OPENINGBRACE expr<x> CLOSINGBRACE { *n = arrCmptProduction * x; }
| OPENINGBRACE expr<x> CLOSINGBRACE { arrCmptProduction = arrCmptProduction * x; } array_complete_dcl<y> 
;

variable<n> :
  ID_CODE<x> { char * str = Lookup(x); if ((str != NULL) && (str[0] != '\0')) { ErrorPrump_IdNotFound(1,x); } else { *n = x; } }
| ID_CODE<x> { char * str = Lookup(x); if ((str != NULL) && (str[0] != '\0')) { ErrorPrump_IdNotFound(1,x); } else { *n = x; } } array_complete_dcl<y> { useOfArrayVar = 1; *n = x; }
| DECREMENT variable<m>
| INCREMENT variable<m>
| variable<m> DECREMENT
| variable<m> INCREMENT
;

const_val<n> :
  INTNUMBER<x> { *n = x; }
| REALNUMBER<x> { *n = x; }
| CHAR<x> { *n = x; }
| BOOLEAN<x> { *n = x; }
| STRING<x> { *n = x; }
;

assignment_expr<n> :
  variable<x> { useOfResVar = 1; VariableName = x; } ASSIGNMENT expr<y> { HandleCodeGenerator("=",x,y,""); useOfResVar = 0; }
;

expr_assign :
  expr<m>
| assignment_expr<m>
;

loop_stmt :
  FOR OPENINGPAREBTHESIS ( var_dcl )? SEMICOLON expr<k> SEMICOLON ( expr_assign )? CLOSINGPAREBTHESIS block<l>
| REPEAT block<m> UNTIL OPENINGPAREBTHESIS expr<l> CLOSINGPAREBTHESIS SEMICOLON
| FOREACH OPENINGPAREBTHESIS ID_CODE<y> { char* str2 = Lookup(y); if ((str2 != NULL) && (str2[0] != '\0')) { AddId(y,"VAR"); } else { ErrorPrump_IdDuplicated(1,y); return; } } IN ID_CODE<z> { char * str1 = Lookup(z); if ((str1 != NULL) && (str1[0] != '\0')) { ErrorPrump_IdNotFound(1,z); } } CLOSINGPAREBTHESIS block<f>
;

term<n> :
  term<x> arithmatic_low_level<y> factor<z> { char* temp = ProduceTempVar(); HandleCodeGenerator(y,temp,x,z); *n = temp; }
| factor<x>
;

factor<n> :
  factor<x> arithmatic_high_level<y> primary<z> { char* temp = ProduceTempVar(); HandleCodeGenerator(y,temp,x,z); *n = temp; }
| primary<x> { *n = x; }
;

primary<n> :
  INTNUMBER<x> { *n = x; }
| REALNUMBER<x> { *n = x; }
| OPENINGPAREBTHESIS term<x> CLOSINGPAREBTHESIS
;

expr<n> :
  term<x>
| expr<x> conditional<m> expr<y>
| OPENINGPAREBTHESIS expr<y> CLOSINGPAREBTHESIS
| method_call_expr
| variable<x> { *n = x; }
| const_val<m>
| SUBUNARYMINUS expr<m>
| NOT expr<m>
;

cond_statement :
  IF OPENINGPAREBTHESIS expr<x> CLOSINGPAREBTHESIS block<y> { char* blockLabel = UseOfBlockLabel(); HandleCodeGenerator("JNZ",blockLabel,x,""); } ( ELSE block<z> { char* blockLabel = UseOfBlockLabel(); HandleCodeGenerator("JZ",blockLabel,z,""); } )?
| SWITCH OPENINGPAREBTHESIS ID_CODE<x> CLOSINGPAREBTHESIS OF COLON OPENCURLYBRACE { EnterScope(); } ( CASE INTNUMBER<y> COLON block<z> )* DEFAULT COLON block<m> CLOSECURLYBRACE { ExitScope(); }
;

gotofunc :
  GOTO ID_CODE<x> { HandleCodeGenerator("JMP",x,"",""); }
;

labeltoken :
  ID_CODE<x> COLON { HandleCodeGenerator("LB",x,"",""); }
;

statement_expr :
  assignment_expr<m> SEMICOLON
| cond_statement
| loop_stmt
| method_call_expr SEMICOLON
| RETURN { int i = 0; } ( expr<x> { i = 1; } )? SEMICOLON { if(i == 0) { HandleCodeGenerator("RET",x,"",""); } else HandleCodeGenerator("RET","","",""); }
| gotofunc SEMICOLON
| labeltoken
| BREAK SEMICOLON
| CONTINUE SEMICOLON
| SIZEOF OPENINGPAREBTHESIS type<m> CLOSINGPAREBTHESIS SEMICOLON
;
